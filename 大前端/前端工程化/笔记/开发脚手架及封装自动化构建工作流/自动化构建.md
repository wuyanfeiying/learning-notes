<!--
 * @Date: 2021-07-17 17:59:55
 * @LastEditors: chuhongguang
-->
[TOC]
### 自动化构建简介
> 一切重复工作本应自动化
- 自动化：机器代替手工完成一些工作
- 构建：转换，把一个东西转换成另外一个东西
```
源代码 --（自动化构建）--> 生成代码
```
开发中写出的源代码自动化构建为生产代码，也可以称之为**自动化构建工作流**。
#### 作用
脱离运行环境中的问题，在开发阶段，使用一些提高效率的语法、规范和标准。
#### 场景
- ECMAScript
- Sass/Less
- 模板引擎
例如在开发网页应用时，我们通过`ECMAScript`最新标准来提高代码效率和质量, 利用 `Sass/Less` 预编译解析器来增强`CSS`的可编辑性。借助模板引擎，来处理重复的HTML。

以上这些商家中提到的用法，**在浏览器中大多数是不能支持被支持使用的**。

我们可以通过，**自动化构建这种方式，构建转换那些不被支持的“特性”**。

### 常用的自动化构建工具
#### Grunt
  - 最早的前端构建工作，插件生态非常完善。
  - 官方说Grunt插件几乎可以帮你完成任务你想做的事情。
  - 工作过程基于临时文件，所以构建过程非常的慢。
#### Gulp
  - 很好的解决了Grunt构建慢的问题
  - 之所以先对较快，是因为它是基于内存实现的，对文件的处理环节都是在内存中完成的，相对于磁盘读写，速度快很多。
  - 默认支持同时执行多个任务，效率相对较高
  - 使用方式相对Grunt, 更加直观易懂
  - 插件生态也比较完善
#### FIS
  - 百度前端团队推出的一款构建系统
  - 更像是一种“捆绑套餐”
  - 典型需求尽可能集成到内部：资源加载、模块开发、代码部署、性能优化，因为大而全，在国内很流行
> 备注： webpack是个打包工具

### Grunt
```js
yarn init --yes // 初始化项目
yarn add grunt // 安装grunt
code gruntfile.js // 安装配置，入口文件，用于去定义一些需要自动执行的任务
```
#### gruntfile.js
- Grunt 的入口文件
- 用于定义一些需要 Grunt 自动执行的任务
- 需要导出一个函数
- 此函数接收一个 grunt 的形参，内部提供一些创建任务时可以用到的API
#### grunt 任务
```js
module.exports = grunt => {
  grunt.resiterTask('foo',()=>{
    console.log('hello grunt~')
  })
}
```
控制台输入：
`yarn grunt foo`

#### grunt 默认任务
```js
grunt.registerTask('default', ()=>{
  console.log('deault task~')
})
// 执行多个任务
grunt.registerTask('dedault',['foo','bar'])
```
控制台输入，执行默认任务：
`yarn grunt`

#### grunt 异步任务
```js
// 错误写法
grunt.registerTask('async-task', ()=>{
  setTimeout(()=>{
    console.log('async task working')
  },1000)
})

// 正确写法
grunt.registerTask('async-task',function (){
  const done = this.async()
  setTimeout(()=>{
    cosnole.log('async task working~')
    done()
  },1000)
})
```
使用async来获取done,异步任务中grunt会根据done回调函数是否执行来判断异步任务是否执行完毕。

#### grunt 标记任务失败
同步任务：
```js
module.exports = grunt => {
  grunt.resiterTask('foo',()=>{
    console.log('hello grunt~')
    return false
  })
}
```
如果是在任务列表中使用 return一个任务，其他任务会被阻塞
```js
module.exports = grunt => {
  grunt.resiterTask('foo',()=>{
    console.log('hello grunt~')
    return false
  })

  grunt.resiterTask('foo1',()=>{
    console.log('hello grunt~')
  })

  grunt.resiterTask('foo2',()=>{
    console.log('hello grunt~')
  })

  grunt.resiterTask('default',['foo','foo1','foo2'])
}
```
可以使用 grunt default --force 强制执行

异步任务：
```js
  grunt.resiterTask('async-foo',function(){
    const foo = this.async()
    setTimeout(()=>{
      console.log('async foo)
      done(false)
    },1000)
  })
```
#### grunt 配置选项方法
比如可以配置压缩的文件路径
```js
module.exports = grunt => {
  grunt.initConfig({
    foo:'bar',
    // foo:{
    //   bar:123
    // }
  })

  grunt.resiterTask('foo',()=>{
    grunt.config('foo')
    // grunt.config('foo.bar')
  })

}
```

#### grunt 多目标任务
多目标模式，可以让任务根据配置形成多个子任务
```js
module.exports = grunt => {
  grunt.initConfig({
    build: {
      options:{
        foo: 'bar'
      },
      css: '1',
      js: '2'
    }
  })

  grunt.registerMultiTask('build', function(){
    this.target // 拿到目标 css
    this.data // 目标对应的值 1
    this.options() // 拿到多有配置选项的内容
  })
}
```

#### grunt 插件的使用
grunt 的核心，很多构建任务都是通用的。
先通过npm安装插件，之后再grunt中载入插件提供的任务，最后根据插件文档完成对应的项目选项。

- 插件举例：清楚项目中临时产生配置文件的插件
安装插件
```js
yarn add grunt-contrib-clean
```
加载插件
```js
module.exports = grunt => {
  // 初始化任务，添加目标
  grunt.initConfig({
    // 插件名
    clean: {
      // temp: 'temp/app.js', // clean 这个插件需要清除临时文件的路径
      // temp: 'temp/*.txt', // 使用通配符的方式，指定插件删除所有后缀为.txt的文件
      temp: 'temp/**', // 找到 temp 下的所有，子目录及及目录文件
    }
  })
  // 加载插件 grunt-contrib-XXX
  grunt.loadNpmTasks('grunt-contrib-clean')
}
```

#### grunt 常用插件
##### grunt-sass
安装插件, 这个插件是再npm里面的，不像官方的，不需要配置本地，依赖npm
```
yarn add grunt-sass
```
加载插件
```js
const sass = require('sass')
module.exports = grunt => {
  // 初始化任务，添加目标
  grunt.initConfig({
    // 插件名
    sass: {
      options:{
        // 载入 sass 模块
        implementation: sass，
        sourceMap: true
      },
      // 主入口
      main:{
        // 输入文件
        files:{
          // 需要输出的 css 路径 --------- 源路径
          'dist/css/main.css': 'src/scss/main.scss'
        }
      }
    }
  })
  // 加载插件 grunt-contrib-XXX
  grunt.loadNpmTasks('grunt-sass')
}
```

##### grunt-babel
编译 ES6语法的插件
```js
// 安装 grunt中 babel 核心模块 以及babel的预设
// --dev 安装开发依赖
yarn add grunt-babel @babel/core @babel/preset-env --dev
```
安装以下插件，不用每次都 grunt.loadNpmTasks（XXX)
```
yarn add load-grunt-taks --dev
```
加载插件
```js
const loadGruntTasks = require('load-grunt-tasks')
module.exports = grunt => {
  // 初始化任务，添加目标
  grunt.initConfig({
    // 插件名
    babel: {
      options:{
        // 把ECMAScript最新的特性全部加载进来
        presets:['@babel/preset-env'],
        sourceMap: true
      },
        // 输入文件
        files:{
          // 需要输出的 css 路径 --------- 源路径
          'dist/js/app.js': 'src/js/app.js'
        }
    }
  })
  // 自动加载所有的grunt插件中的任务
  loadGruntTasks(grunt)
}
```

#### grunt-contrib-warch
文件修改完之后，需要自动去编译
```js
yarn add grunt-contrib-warch --dev
```
加载插件
```js
const loadGruntTasks = require('load-grunt-tasks')
module.exports = grunt => {
  // 初始化任务，添加目标
  grunt.initConfig({
    sass: {
      options:{
        // 载入 sass 模块
        implementation: sass，
        sourceMap: true
      },
      // 主入口
      main:{
        // 输入文件
        files:{
          // 需要输出的 css 路径 --------- 源路径
          'dist/css/main.css': 'src/scss/main.scss'
        }
      }
    },
    babel: {
      options:{
        // 把ECMAScript最新的特性全部加载进来
        presets:['@babel/preset-env'],
        sourceMap: true
      },
        // 输入文件
        files:{
          // 需要输出的 css 路径 --------- 源路径
          'dist/js/app.js': 'src/js/app.js'
        }
    },
    // 插件名
    watch: {
      // 监听目标-js
      js:{
        // 监视的JS文件集合
        files:['src/js/*.js'],
        // 当目标发升改变的时候，需要执行什么任务
        tasks:['babel']
      }，
      // 监听目标-js
      css:{
        // 监视的JS文件集合
        files:['src/scss/*.scss'],
        // 当目标发升改变的时候，需要执行什么任务
        tasks:['sass']
      }，
    }
  })
  // 自动加载所有的grunt插件中的任务
  loadGruntTasks(grunt)

  // 映射，让监听一开始就执行
  // 先启动任务，再执行监听
  grunt.registerTask('default'，['sass','babel','watch'])
}
```

### Gulp
#### 基本使用
1. 在项目中安装 gulp 依赖包
2. 在项目根目录中添加 gulp.files的文件，用来配置需要执行的构建任务
3. 使用 gulp提供的 cli来运行构建任务
初始化项目
```
yarn init --yes
```
安装Gulp模块
```
yarn add gulp --dev
```
新建 Gulp 入口文件 `gulpfile.js`
```js
// 建立一个 foor任务
exports.foo = () =>{
	console.log('foo task working~')
}
```
执行任务
```	
yarn gulp foo
```
gulp默认都是异步任务，需要在完成之后，标记任务是否完成
```js
// 建立一个 foor 任务
exports.foo = done =>{
	console.log('foo task working~')
	done() // 标识任务完成
}
```
默认任务
```js
exports.defualt = done => {
	console.log('default task working~')
	done()
}
```
运行默认任务

```bash
yarn gulp
```
#### 创建组合任务
可以创建 并行任务 或 串行任务

```javascript
const {series, parallel } = require('gulp') 
// 依次执行任务-串行任务
exports.foo =series(task1,task2,task3)

// 并行任务
exports.bar = parallel(task1,task2,task3)
```
#### 异步任务的三种方式
##### 通过回调的方式解决

```javascript
exports.callback = done => {
	console.log('callback task~')
	done()
}

// 回调函数中的参数，错误优先
exports.callback_error = done => {
	console.log('callback task~')
	done(new Error('task failed! '))
}
```
##### 通过Promise的方式解决
一旦我们返回的任务`resolve`了，那么这个任务就结束了。
```javascript
exports.promise = () => {
	console.log('promise task~')
	return Promise.resolve()
}

exports.promise_error = () => {
	console.log('promise task~')
	return Promise.reject(new Error('task failed ~'))
}
```
`ES7`新增的 `async await`
promise语法糖

```javascript
const timeout = time => {
	return new Promise(resolve =>{
		setTimeout(resolve,time)
	})
}

exports.async = async ()=>{
	await timeout(1000)
	consoe.log('async task~')
}
```

##### 通过stream方式解决

```javascript
const fs = require('fs')

exports.stream = () => {
	// 创建一个读取文件的流程
	const readSteram = fs.createReadStream('package.json')
	// 创建一个写入文件的流程
	const writeStream = fs.createWriteStream('temp.txt')
	// 类似于 从一个水池子到另一个水池子倒水
	// 起到文件复制的作用
	readSteram.pipe(writeStream )
return readSteram
}
```
`Gulp`捕获到`readSteram`中的`end`事件，然后结束

```javascript
const fs = require('fs')

exports.stream = done => {
	....
	readSteram.pipe(writeStream )
	readSteram.on('end', () => {
		done()
	})
}
```

#### 构建过程核心工作原理

```javascript
输入 --> 加工 --> 输出
```
压缩代码为例：

```javascript
读取文件 --> 压缩文件 --> 写入文件
```
`gulpfile.js`

```javascript
const fs = require('fs')
const { Transform } = require('stream')

exports.default = () => {
	// 文件读取流
	const read = fs.createReadStreaam('a.css')
	// 文件写入流
	const write = fs.createWriteStream('a.min.css')
	// 文件转换流
	const transform = new Transform({
		transform:(chunk, encoding, callback){
			// 核心转换过程实现
			// chunk => 读取流中读取到的内容 （Buffer）
			const input = chunk.toString()
			// 匹配空白符、注释
			const output = input.replace(/\s+/g,'').replace(/\/\*.+?\*\//g,'')
			// 错误优先的回调函数
			callback(null,output)
		}
	})

	// 把读取出来的文件流导入写入文件流
	read
	.pipe(transform) // 转换
	.pipe(write) // 写入
	return read
}
```
#### 文件操作API+ 插件的使用

```js
const { src, dest } = require('gulp')

exports.default = () => {
//  return src('src/normalize.css') // 文件读取流
 return src('src/*.css') // 文件读取流
  .pipe(dest('dist')) // 通过pipe放入到dest指定的写入流当中
}
```
安装 gulp 提供的CSS压缩的插件
```
yarn add gulp-clean-css --dev
```
```js
const { src, dest } = require('gulp')
const cleanCss = require('gulp-clean-css')

exports.default = () => {
//  return src('src/normalize.css') // 文件读取流
 return src('src/*.css') // 文件读取流
  .pipe(cleanCss()) // CSS压缩转换
  .pipe(dest('dist')) // 通过pipe放入到dest指定的写入流当中
}
```
安装 gulp 提供的gulp-rename的插件
```
yarn add gulp-rename --dev
```
```js
...
const rename = require('gulp-rename')

exports.default = () => {
//  return src('src/normalize.css') // 文件读取流
 return src('src/*.css') // 文件读取流
  .pipe(cleanCss()) // CSS压缩转换
  .pipe(rename({ extname: '.min.css'})) // 重命名扩展名
  .pipe(dest('dist')) // 通过pipe放入到dest指定的写入流当中
}
```